<?php

/**
 * @file
 * Allows entities to be translated into different languages.
 *
 * @todo
 * - menu
 * - core entities
 */

module_load_include('inc', 'entity_translation', 'entity_translation.node');

/**
 * TODO
 */
function entity_translation_language($entity_type, $entity) {
  $handler = entity_translation_get_handler($entity_type, $entity);
  $langcode = $handler->getFormLanguage();
  return !empty($langcode) ? $langcode : $handler->getLanguage();
}

/**
 * Helper function to determine if the given entity type is translatable.
 */
function entity_translation_enabled($entity_type, $skip_handler = FALSE) {
  $enabled_types = variable_get('entity_translation_entity_types', array());
  return !empty($enabled_types[$entity_type]) && ($skip_handler || field_has_translation_handler($entity_type, 'entity_translation'));
}

/**
 * Implements hook_language_type_info_alter().
 */
function entity_translation_language_types_info_alter(array &$language_types) {
  unset($language_types[LANGUAGE_TYPE_CONTENT]['fixed']);
}

/**
 * Implements hook_translation_info().
 */
function entity_translation_translation_info($types = NULL) {
  $info = array(
    'comment' => array(
      'translation' => array(
        'entity_translation' => array(
          'edit form' => FALSE,
        ),
      ),
    ),
    'node' => array(
      'translation' => array(
        'entity_translation' => array(
          'class' => 'EntityTranslationNodeHandler',
          'alias' => TRUE,
          'access callback' => 'entity_translation_node_tab_access',
          'access arguments' => array(1),
        ),
      ),
    ),
    'taxonomy_term' => array(
      'translation' => array(
        'entity_translation' => array(
          'base path' => 'taxonomy/term/%taxonomy_term',
          'alias' => TRUE,
        ),
      ),
    ),
    'user' => array(
    ),
  );

  return isset($types) ? array_intersect_key($info, $types) : $info;
}

/**
 * Implements hook_entity_info_alter().
 */
function entity_translation_entity_info_alter(&$entity_info) {
  // Collect entity-specific translation information.
  $types = array_flip(array_keys($entity_info));
  $translation_info = module_invoke_all('translation_info', $types);
  $entity_info = array_merge_recursive($entity_info, $translation_info);
  $edit_form_info = array();

  // Provide defaults for translation info.
  foreach ($entity_info as $entity_type => $info) {
    if (entity_translation_enabled($entity_type, TRUE)) {
      $entity_info[$entity_type]['language callback'] = 'entity_translation_language';

      if (!isset($entity_info[$entity_type]['translation']['entity_translation'])) {
        $entity_info[$entity_type]['translation']['entity_translation'] = array();
      }

      // If no base path is provided we default to the common "node/%node"
      // pattern.
      if (!isset($entity_info[$entity_type]['translation']['entity_translation']['base path'])) {
        // Give a hint we are not done yet with entity translation information
        // building, since if caches have been cleared also menu cache is going
        // to be rebuilt and would retrieve an incomplete entity information.
        $GLOBALS['entity_translation_info_building'] = TRUE;
        $router = menu_get_router();
        unset($GLOBALS['entity_translation_info_building']);

        // If we cannot find a usable base path we skip to the next entity type.
        if (!isset($router["$entity_type/%"])) {
          unset($entity_info[$entity_type]['translation']['entity_translation']);
          continue;
        }

        $path = "$entity_type/%$entity_type";
        $entity_info[$entity_type]['translation']['entity_translation']['base path'] = $path;
      }

      $path = $entity_info[$entity_type]['translation']['entity_translation']['base path'];

      $entity_info[$entity_type]['translation']['entity_translation'] += array(
        'view path' => $path,
        'edit path' => "$path/edit",
        'class' => 'EntityTranslationDefaultHandler',
        'path wildcard' => "%$entity_type",
        'access callback' => 'entity_translation_tab_access',
        'access arguments' => array($entity_type),
        'theme callback' => 'variable_get',
        'theme arguments' => array('admin_theme'),
        'edit form' => TRUE,
      );

      $entity_info[$entity_type]['entity keys'] += array(
        'translations' => 'translations',
      );
    }
  }
}

/**
 * Implements hook_menu().
 */
function entity_translation_menu() {
  $items = array();

  $items['admin/config/regional/entity_translation'] = array(
    'title' => 'Entity translation',
    'description' => 'Configure which entities can be translated and enable or disable language falback.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_translation_admin_form'),
    'access arguments' => array('administer entity translation'),
    'file' => 'entity_translation.admin.inc',
    'module' => 'entity_translation',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function entity_translation_menu_alter(&$items) {
  // If entity translation information is being rebuilt we must not proceed to
  // avoid recursion.
  if (!empty($GLOBALS['entity_translation_info_building'])) {
    return;
  }

  $backup = array();
  $tab_info = array();
  $languages = entity_translation_languages();

  // Create tabs for all possible entity types.
  foreach (entity_get_info() as $entity_type => $info) {
    // Menu is rebuilt while determining entity translation base paths and
    // callbacks so we might not have them available yet.
    if (entity_translation_enabled($entity_type)) {
      // Extract informations from the bundle description.
      $path = $info['translation']['entity_translation']['base path'];
      $keys = array('theme callback', 'theme arguments', 'access callback', 'access arguments', 'load arguments');
      $item = array_intersect_key($info['translation']['entity_translation'], drupal_map_assoc($keys));

      $item += array(
        'file' => 'entity_translation.admin.inc',
        'module' => 'entity_translation',
      );

      $entity_position = count(explode('/', $path)) - 1;
      $source_position = $entity_position + 4;
      $language_position = $entity_position + 3;

      // Backup existing values for the translate overview page.
      if (isset($items["$path/translate"])) {
        $backup[$entity_type] = $items["$path/translate"];
      }

      $items["$path/translate"] = array(
        'title' => 'Translate',
        'page callback' => 'entity_translation_overview',
        'page arguments' => array($entity_type, $entity_position),
        'type' => MENU_LOCAL_TASK,
        'weight' => 2,
      ) + $item;

      $et_info = $info['translation']['entity_translation'];
      $edit_path = $et_info['edit path'];

      if (isset($items[$edit_path])) {
        $edit_form_item = $items[$edit_path];
        $entity_position = count(explode('/', $et_info['base path'])) - 1;

        // We iterate on every installed language here, they will be filtered
        // when checking access.
        foreach ($languages as $langcode => $language) {
          $items["$edit_path/$langcode"] = array(
            'type' => MENU_LOCAL_TASK,
            'title' => $language->name,
            'page callback' => 'entity_translation_edit_page',
            'page arguments' => array_merge(array($entity_type, $entity_position, $langcode, $edit_form_item), $edit_form_item['page arguments']),
            'access callback' => 'entity_translation_edit_access',
            'access arguments' => array_merge(array($entity_type, $entity_position, $langcode, $edit_form_item), $edit_form_item['access arguments']),
            'weight' => $language->weight,
          );
        }

        // Replace the main edit callback with our proxy implementation to set
        // form language to the current language.
        $items[$edit_path]['page callback'] = 'entity_translation_edit_page';
        $items[$edit_path]['page arguments'] = array_merge(array($entity_type, $entity_position, NULL, $edit_form_item), $edit_form_item['page arguments']);

        // Add translation callback.
        $add_path = "$edit_path/add/%entity_translation_language/%entity_translation_language";
        $language_position = $entity_position + 3;
        $source_position = $entity_position + 4;
        $items[$add_path] = array(
          'title callback' => 'Add translation',
          'page callback' => 'entity_translation_add_page',
          'page arguments' => array_merge(array($entity_type, $entity_position, $language_position, $source_position, $edit_form_item), $edit_form_item['page arguments']),
          'type' => MENU_LOCAL_TASK,
          'access callback' => 'entity_translation_add_access',
          'access arguments' => array_merge(array($entity_type, $entity_position, $language_position, $source_position, $edit_form_item), $edit_form_item['access arguments']),
        );

        // Delete translation callback.
        $items["$edit_path/delete/%entity_translation_language"] = array(
          'title' => 'Delete',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('entity_translation_delete_confirm', $entity_type, $entity_position, $language_position),
        ) + $item;

        // Store tab info to be able to be able to efficiently get basic entity
        // information from the related edit form router path.
        $router_path = preg_replace('/%' . DRUPAL_PHP_FUNCTION_PATTERN . '/', '%', $edit_path); 
        $tab_info[$router_path] = array(
          'entity type' => $entity_type,
          'entity' => $entity_position,
        );

        $router_path = preg_replace('/%' . DRUPAL_PHP_FUNCTION_PATTERN . '/', '%', $add_path);
        $tab_info[$router_path] = array(
          'entity type' => $entity_type,
          'entity' => $entity_position,
          'language' => $language_position,
          'source' => $source_position,
        );
      }
    }
  }

  // Store the tab information.
  variable_set('entity_translation_tab_info', $tab_info);

  // Node-specific menu alterations.
  entity_translation_node_menu_alter($items, $backup);
}

/**
 * Access callback.
 */
function entity_translation_edit_access() {
  $args = func_get_args();
  $entity_type = array_shift($args);
  $entity = array_shift($args);
  $langcode = array_shift($args);

  $handler = entity_translation_get_handler($entity_type, $entity);
  $translations = $handler->getTranslations();

  // If the translation exists, we can show the corresponding local task.
  if (isset($translations->data[$langcode])) {
    // Check that the requested language is actually accessible.
    $enabled_languages = entity_translation_languages($entity_type, $entity);
    if (isset($enabled_languages[$langcode])) {
      $edit_form_item = array_shift($args);
      return _entity_translation_callback($edit_form_item['access callback'], $args, $edit_form_item);
    }
  }

  return FALSE;
}

/**
 * Page callback.
 */
function entity_translation_edit_page() {
  $args = func_get_args();
  $entity_type = array_shift($args);
  $entity = array_shift($args);
  $langcode = array_shift($args);
  $edit_form_item = array_shift($args);

  // Set the current form language.
  $langcode = entity_translation_form_language($entity_type, $entity, $langcode);
  $handler = entity_translation_get_handler($entity_type, $entity);
  $handler->setFormLanguage($langcode);

  // Display the entity edit form.
  return _entity_translation_callback($edit_form_item['page callback'], $args, $edit_form_item);
}

/**
 * Access callback.
 */
function entity_translation_add_access() {
  $args = func_get_args();
  $entity_type = array_shift($args);
  $entity = array_shift($args);
  $langcode = array_shift($args);
  $source = array_shift($args);

  $handler = entity_translation_get_handler($entity_type, $entity);
  $translations = $handler->getTranslations();

  // If the translation does not exist we can show the tab.
  if (!isset($translations->data[$langcode]) && $langcode != $source) {
    // Check that the requested language is actually accessible.
    $enabled_languages = entity_translation_languages($entity_type, $entity);
    if (isset($enabled_languages[$langcode])) {
      $edit_form_item = array_shift($args);
      return _entity_translation_callback($edit_form_item['access callback'], $args, $edit_form_item);
    }
  }

  return FALSE;
}

/**
 * Page callback.
 */
function entity_translation_add_page() {
  $args = func_get_args();
  $entity_type = array_shift($args);
  $entity = array_shift($args);
  $langcode = array_shift($args);
  $source = array_shift($args);
  $edit_form_item = array_shift($args);

  $handler = entity_translation_get_handler($entity_type, $entity);
  $handler->setFormLanguage($langcode);

  // Display the entity edit form.
  return _entity_translation_callback($edit_form_item['page callback'], $args, $edit_form_item);
}

/**
 * TODO
 */
function entity_translation_form_language($entity_type, $entity, $langcode = NULL) {
  if (empty($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }
  $handler = entity_translation_get_handler($entity_type, $entity);
  $translations = $handler->getTranslations();
  return isset($translations->data[$langcode]) ? $langcode : $handler->getLanguage();
}

/**
 * TODO
 */
function _entity_translation_callback($callback, $args, $info = array()) {
  if (isset($info['file'])) {
    $path = isset($info['file path']) ? $info['file path'] : drupal_get_path('module', $info['module']);
    include_once DRUPAL_ROOT . '/' . $path . '/' . $info['file'];
  }
  return call_user_func_array($callback, $args);
}

/**
 * TODO
 */
function entity_translation_tab_info($router_path = NULL) {
  $tab_info = variable_get('entity_translation_tab_info', array());

  if (empty($router_path)) {
    $item = menu_get_item();
    $router_path = $item['path'];
  }

  if (isset($tab_info[$router_path])) {
    $info = $tab_info[$router_path];
    $result = array('entity type' => $info['entity type']);
    unset($info['entity type']);
    $item = isset($item) ? $item : menu_get_item();
    foreach ($info as $key => $position) {
      $result[$key] = $item['map'][$info[$key]];
    }
    return $result;
  }

  return FALSE;
}

/**
 * TODO
 */
function entity_translation_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // When displaying the main edit form, we need to mark as active the tab
  // corresponding to the current language;
  if ($router_item['path'] == $root_path && ($info = entity_translation_tab_info($root_path))) {
    $langcode = entity_translation_form_language($info['entity type'], $info['entity']);
    $languages = language_list();

    foreach ($data['tabs'][1]['output'] as &$tab) {
      if (empty($info['source'])) {
        $segments = explode('/', $tab['#link']['path']);
        if ($segments[count($segments) - 1] == $langcode) {
          $tab['#active'] = TRUE;
          break;
        }
      }
      // Add translation tab.
      elseif ($tab['#link']['path'] == $root_path) {
        $tab['#link']['title'] = $languages[$info['language']]->name;
        $tab['#link']['weight'] = -$languages[$info['language']]->weight;
        $tab['#active'] = TRUE;
        break;
      }
    }

    // Reorder tabs to make the add tab respect language weights.
    if (!empty($info['source'])) {
      usort($data['tabs'][1]['output'], '_entity_translation_tab_sort');
    }
  }
}

/**
 * TODO
 */
function _entity_translation_tab_sort($a, $b) {
  return $a['#link']['weight'] > $b['#link']['weight'];
}

/**
 * Implements hook_admin_paths().
 */
function entity_translation_admin_paths() {
  $paths = array();
  foreach (entity_get_info() as $entity_type => $info) {
    if (entity_translation_enabled($entity_type, TRUE) && isset($info['translation']['entity_translation']['base path'])) {
      $base_path = preg_replace('|%[^/]*|', '*', $info['translation']['entity_translation']['base path']);
      $paths["$base_path/translate"] = TRUE;
      $paths["$base_path/translate/*"] = TRUE;
      $paths["$base_path/edit/*"] = TRUE;
    }
  }
  return $paths;
}

/**
 * Access callback.
 */
function entity_translation_tab_access($entity_type) {
  return drupal_multilingual() && (user_access('translate any entity') || user_access("translate $entity_type entities"));
}

/**
 * Menu loader callback.
 */
function entity_translation_language_load($langcode, $entity_type = NULL, $entity = NULL) {
  $enabled_languages = entity_translation_languages($entity_type, $entity);
  return isset($enabled_languages[$langcode]) ? $langcode : FALSE;
}

/**
 * Menu loader callback.
 */
function entity_translation_menu_entity_load($entity_id, $entity_type) {
  $entities = entity_load($entity_type, array($entity_id));
  return $entities[$entity_id];
}

/**
 * Implements hook_permission().
 */
function entity_translation_permission() {
  $permission = array(
    'translate any entity' => array(
      'title' => t('Translate any entity'),
      'description' => t('Translate field content for any fieldable entity.'),
    ),
    'administer entity translation' => array(
      'title' => t('Administer entity translation'),
      'description' => t('Select which entities can be translated.'),
    ),
  );
  foreach (entity_get_info() as $entity_type => $info) {
    if ($info['fieldable']) {
      $label = t($info['label']);
      $permission["translate $entity_type entities"] = array(
        'title' => t('Translate entities of type @type', array('@type' => $label)),
        'description' => t('Translate field content for entities of type @type', array('@type' => $label)),
      );
    }
  }
  return $permission;
}

/**
 * Implements hook_theme().
 */
function entity_translation_theme() {
  return array(
    'entity_translation_unavailable' => array(
      'variables' => array('element' => NULL),
    ),
  );
}

/**
 * Implements hook_entity_load().
 */
function entity_translation_entity_load($entities, $entity_type) {
  if (entity_translation_enabled($entity_type)) {
    EntityTranslationDefaultHandler::loadMultiple($entity_type, $entities);
  }
}

/**
 * Implements hook_field_language_alter().
 *
 * Performs language fallback for unaccessible translations.
 */
function entity_translation_field_language_alter(&$display_language, $context) {
  if (variable_get('locale_field_language_fallback', TRUE) && entity_translation_enabled($context['entity_type'])) {
    $entity = $context['entity'];
    $entity_type = $context['entity_type'];
    $handler = entity_translation_get_handler($entity_type, $entity);
    $translations = $handler->getTranslations();

    // Apply fallback only on unpublished translations as missing translations
    // are already handled in locale_field_language_alter().
    if (isset($translations->data[$context['language']]) && !entity_translation_access($entity_type, $translations->data[$context['language']])) {
      list(, , $bundle) = entity_extract_ids($entity_type, $entity);
      $instances = field_info_instances($entity_type, $bundle);
      $entity = clone($entity);

      foreach ($translations->data as $langcode => $translation) {
        if ($langcode == $context['language'] || !entity_translation_access($entity_type, $translations->data[$langcode])) {
          // Unset unaccessible field translations: if the field is
          // untranslatable unsetting a language different from LANGUAGE_NONE
          // has no effect.
          foreach ($instances as $instance) {
            unset($entity->{$instance['field_name']}[$langcode]);
          }
        }
      }

      // Find the new fallback values.
      locale_field_language_fallback($display_language, $entity, $context['language']);
    }
    elseif (!field_has_translation_handler($entity_type, 'locale')) {
      // If not handled by the Locale translation handler trigger fallback too.
      locale_field_language_fallback($display_language, $entity, $context['language']);
    }
  }
}

/**
 * Implements hook_field_attach_view_alter().
 *
 * Hide the entity if no translation is available for the current language and
 * language fallback is disabled.
 */
function entity_translation_field_attach_view_alter(&$output, $context) {
  if (!variable_get('locale_field_language_fallback', TRUE) && entity_translation_enabled($context['entity_type'])) {
    $handler = entity_translation_get_handler($context['entity_type'], $context['entity']);
    $translations = $handler->getTranslations();
    $langcode = $GLOBALS['language_content']->language;

    // If fallback is disabled we need to notify the user that the translation
    // is unavailable (missing or unpublished).
    if (!isset($translations->data[$langcode]) || !entity_translation_access($context['entity_type'], $translations->data[$langcode])) {
      // Provide context for rendering.
      $output['#entity'] = $context['entity'];
      $output['#entity_type'] = $context['entity_type'];
      $output['#view_mode'] = $context['view_mode'];
      // We perform theming here because the theming function might need to set
      // system messages. It would be too late in the #post_render callback.
      $output['#entity_translation_unavailable'] = theme('entity_translation_unavailable', array('element' => $output));
      // As we used a string key, other modules implementing
      // hook_field_attach_view_alter() may unset/override this.
      $output['#post_render']['entity_translation'] = 'entity_translation_unavailable';
    }
  }
}

/**
 * Override the entity output with the unavailable translation one.
 */
function entity_translation_unavailable($children, $element) {
  return $element['#entity_translation_unavailable'];
}

/**
 * Theme an unvailable translation.
 */
function theme_entity_translation_unavailable($variables) {
  $element = $variables['element'];
  $handler = entity_translation_get_handler($element['#entity_type'], $element['#entity']);
  $args = array('%language' => t($GLOBALS['language_content']->name), '%label' => $handler->getLabel());
  $message = t('%language translation unavailable for %label.', $args);
  $classes = $element['#entity_type'] . ' ' . $element['#entity_type'] . '-' . $element['#view_mode'];
  return "<div class=\"$classes\"><div class=\"messages warning\">$message</div></div>";
}

/**
 * Implements hook_field_attach_insert().
 */
function entity_translation_field_attach_insert($entity_type, $entity) {
  if (entity_translation_enabled($entity_type)) {
    $handler = entity_translation_get_handler($entity_type, $entity);
    $handler->initTranslations();
    $handler->saveTranslations();
  }
}

/**
 * Implements hook_field_attach_update().
 */
function entity_translation_field_attach_update($entity_type, $entity) {
  if (entity_translation_enabled($entity_type)) {
    $handler = entity_translation_get_handler($entity_type, $entity, TRUE);
    $handler->updateTranslations();
    $handler->saveTranslations();
  }
}

/**
 * Implements hook_field_attach_delete().
 */
function entity_translation_field_attach_delete($entity_type, $entity) {
  if (entity_translation_enabled($entity_type)) {
    $handler = entity_translation_get_handler($entity_type, $entity);
    $handler->removeTranslations();
    $handler->saveTranslations();
  }
}

/**
 * Implements hook_form_alter().
 */
function entity_translation_form_alter(&$form, &$form_state) {
  if (($info = entity_translation_edit_form_info($form)) && entity_translation_enabled($info['entity type']) && !entity_translation_node($info['entity type'], $info['entity'])) {
    $handler = entity_translation_get_handler($info['entity type'], $info['entity']);

    if (!$handler->isNewEntity()) {
      $translations = $handler->getTranslations();
      $form_langcode = $handler->getFormLanguage();
      $langcode = $handler->getLanguage();
      $is_translation = $langcode != $form_langcode;
      $new_translation = !isset($translations->data[$form_langcode]);

      $form['#handler'] = $handler;

      // Display source language selector only if we are creating a new translation
      // and there are at least two translations available.
      if ($new_translation && count($translations->data) > 1) {
        $tab_info = entity_translation_tab_info();
        $form['source_language'] = array(
          '#type' => 'fieldset',
          '#title' => t('Source language'),
          '#collapsible' => TRUE,
          '#collapsed' => TRUE,
          '#tree' => TRUE,
          '#weight' => -100,
          'language' => array(
            '#type' => 'select',
            '#default_value' => $tab_info['source'],
            '#options' => array(),
          ),
          'submit' => array(
            '#type' => 'submit',
            '#value' => t('Change'),
            '#submit' => array('entity_translation_entity_form_source_language_submit'),
          ),
        );
        foreach (language_list() as $language) {
          if (isset($translations->data[$language->language])) {
            $form['source_language']['language']['#options'][$language->language] = t($language->name);
          }
        }
      }

      if ($is_translation) {
        if (isset($form['language'])) {
          // If we are editing a translation set the correct value in the
          // language widget and not current one.
          // @todo Consider supporting the ability to change translation
          // language.
          $languages = language_list();
          $form['language']['#options'][$langcode] = $languages[$langcode]->name;
          $form['language']['#default_value'] = $langcode;
          $form['language']['#disabled'] = TRUE;
        }

        // Replace the delete button with the delete translation one.
        if (!$new_translation) {
          $form['actions']['delete_translation'] = array(
            '#type' => 'submit',
            '#value' => t('Delete translation'),
            '#weight' => $form['actions']['delete'],
            '#submit' => array('entity_translation_entity_form_delete_translation_submit'),
          );
        }
        unset($form['actions']['delete']);

        // Set page title.
        $args = array('@label' => $handler->getLabel(), '@language' => t($languages[$form_langcode]->name));
        drupal_set_title(t('@label [@language translation]', $args));
      }
      else {
        $form['actions']['delete']['#submit'][] = 'entity_translation_entity_form_delete_submit';
      }

      // We need to display the translation tab only when there is at least one
      // translation available or a new one is about to be created.
      if ($new_translation || count($translations->data) > 1) {
        $form['translation'] = array(
          '#type' => 'fieldset',
          '#title' => t('Translation'),
          '#collapsible' => TRUE,
          '#tree' => TRUE,
        );

        $status = $new_translation || $translations->data[$form_langcode]['status'];
        $enabled = !$status;
        // If there is only one published translation we cannot unpublish it,
        // since there would be no content left to display. The whole entity
        // should be unpublished instead, where possible.
        if (!empty($status)) {
          $published = 0;
          foreach ($translations->data as $langcode => $translation) {
            $published += $translation['status'];
          }
          $enabled = $published > 1;
        }
        $description = $enabled ?
          t('An unpublished translation will not be visible for non-administrators.') :
          t('Only this translation is published. You must publish at least one more translation to unpublish this one.');

        $form['translation']['status'] = array(
          '#type' => 'checkbox',
          '#title' => t('This translation is published'),
          '#default_value' => $status,
          '#description' => $description,
          '#disabled' => !$enabled,
        );

        if (!$is_translation) {
          $form['translation']['retranslate'] = array(
            '#type' => 'checkbox',
            '#title' => t('Flag translations as outdated'),
            '#default_value' => 0,
            '#description' => t('If you made a significant change, which means translations should be updated, you can flag all translations of this post as outdated. This will not change any other property of those posts, like whether they are published or not.'),
          );
        }
        else {
          $translate = !$new_translation && $translations->data[$form_langcode]['translate'];
          $form['translation']['translate'] = array(
            '#type' => 'checkbox',
            '#title' => t('This translation needs to be updated'),
            '#default_value' => $translate,
            '#description' => t('When this option is checked, this translation needs to be updated because the source post has changed. Uncheck when the translation is up to date again.'),
            '#disabled' => !$translate,
          );

          $name = $new_translation ? '' : user_load($translations->data[$form_langcode]['uid'])->name;
          $form['translation']['name'] = array(
            '#type' => 'textfield',
            '#title' => t('Authored by'),
            '#maxlength' => 60,
            '#autocomplete_path' => 'user/autocomplete',
            '#default_value' => $name,
            '#description' => t('Leave blank for %anonymous.', array('%anonymous' => variable_get('anonymous', t('Anonymous')))),
          );

          $date = $new_translation ? REQUEST_TIME : $translations->data[$form_langcode]['created'];
          $form['translation']['created'] = array(
            '#type' => 'textfield',
            '#title' => t('Authored on'),
            '#maxlength' => 25,
            '#description' => t('Format: %time. The date format is YYYY-MM-DD and %timezone is the time zone offset from UTC. Leave blank to use the time of form submission.', array('%time' => format_date($date, 'custom', 'Y-m-d H:i:s O'), '%timezone' => format_date($date, 'custom', 'O'))),
            '#default_value' => $new_translation ? '' : format_date($date, 'custom', 'Y-m-d H:i:s O'),
          );
        }
      }

      // Add form handlers.
      $form['actions']['submit']['#submit'][] = 'entity_translation_entity_form_submit';
      array_unshift($form['#validate'], 'entity_translation_entity_form_validate');

      // Node specific alterations.
      if ($info['entity type'] == 'node') {
        entity_translation_node_alter_form($form, $form_state, $handler);
      }
    }
  }
}

/**
 * Implementation of hook_field_attach_form().
 */
function entity_translation_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  if (entity_translation_enabled($entity_type)) {
    $handler = entity_translation_get_handler($entity_type, $entity);
    $translations = $handler->getTranslations();
    $tab_info = entity_translation_tab_info();

    // If we are creating a new translation we need to retrieve form elements
    // populated with the source language values, but only if form is not being
    // rebuilt. In this case source values have already been populated, so we
    // need to preserve possible changes.
    if (!$form_state['rebuild'] && !isset($translations->data[$langcode]) && !empty($tab_info['source']) && isset($translations->data[$source = $tab_info['source']])) {
      list(, , $bundle) = entity_extract_ids($entity_type, $entity);
      foreach (field_info_instances($entity_type, $bundle) as $instance) {
        $field_name = $instance['field_name'];
        $field = field_info_field($field_name);

        // If we are creating a new translation we have to change the form item
        // language information from source to target language, this way the
        // user can find the form items already populated with the source values
        // while the field form element holds the correct language information.
        if ($field['translatable']) {
          $form[$field_name]['#field_name'] = $field_name;
          $form[$field_name]['#source'] = $source;

          // Swap default values during form processing to avoid recursion. We
          // try to act before any other callback so that the correct values are
          // already in place for them.
          if (!isset($form[$field_name]['#process'])) {
            $form[$field_name]['#process'] = array();
          }
          array_unshift($form[$field_name]['#process'], 'entity_translation_prepare_element');
        }
      }
    }
  }
}

/**
 * Form element process callback.
 */
function entity_translation_prepare_element($element, &$form_state) {
  $source_form = drupal_static(__FUNCTION__);

  if (!isset($source_form)) {
    $source_form = array();
    $source_form_state = $form_state;
    $info = entity_translation_edit_form_info($form_state['complete form']);
    field_attach_form($info['entity type'], $info['entity'], $source_form, $source_form_state, $element['#source']);
  }

  $source = $element['#source'];
  $langcode = $element['#language'];
  $field_name = $element['#field_name'];

  // If we are creating a new translation we have to change the form item
  // language information from source to target language, this way the
  // user can find the form items already populated with the source values
  // while the field form element holds the correct language information.
  if (isset($source_form[$field_name][$source])) {
    $element[$langcode] = $source_form[$field_name][$source];
    array_walk_recursive($element[$langcode], '_entity_translation_form_language_callback', $langcode);
  }

  return $element;
}

/**
 * Helper callback: replace the source language with the given one.
 */
function _entity_translation_form_language_callback(&$item, $key, $langcode) {
  if ($key === '#language') {
    $item = $langcode;
  }
}

/**
 * Submit handler for the source language selector.
 */
function entity_translation_entity_form_source_language_submit($form, &$form_state) {
  $handler = $form['#handler'];
  $langcode = $form_state['values']['source_language']['language'];
  $path = "{$handler->getEditPath()}/add/{$handler->getFormLanguage()}/$langcode";
  $form_state['redirect'] = array('path' => $path);
  $languages = language_list();
  drupal_set_message(t('Source translation set to: %language', array('%language' => t($languages[$langcode]->name))));
}

/**
 * Submit handler for the entity deletion.
 */
function entity_translation_entity_form_delete_submit($form, &$form_state) {
  $info = entity_get_info($form['#entity_type']);
  drupal_set_message(t('This will delete all the @entity_type translations.', array('@entity_type' => drupal_strtolower($info['label']))), 'warning');
}

/**
 * Submit handler for the translation deletion.
 */
function entity_translation_entity_form_delete_translation_submit($form, &$form_state) {
  $form_state['redirect'] = "{$form['#handler']->getEditPath()}/delete/{$form['#handler']->getFormLanguage()}";
}

/**
 * Validation handler for the entity edit form.
 */
function entity_translation_entity_form_validate($form, &$form_state) {
  if (isset($form_state['values']['language']) && empty($form['language']['#attributes']['disabled'])) {
    $info = entity_translation_edit_form_info($form);
    $handler = entity_translation_get_handler($info['entity type'], $info['entity']);
    // Update the form language as it might have changed.
    $handler->setFormLanguage($form_state['values']['language']);
  }
}

/**
 * Submit handler for the translation saving.
 */
function entity_translation_entity_form_submit($form, &$form_state) {
  $handler = $form['#handler'];
  $langcode = $handler->getFormLanguage();
  // Redirect to the URL having content language matching the one being edited.
  $links = language_negotiation_get_switch_links(LANGUAGE_TYPE_CONTENT, $handler->getViewPath());
  if (!empty($links->links[$langcode]['href'])) {
    $form_state['redirect'] = array(
      $links->links[$langcode]['href'],
      $links->links[$langcode],
    );
  }
}

/**
 * Implementation of hook_field_attach_submit().
 *
 * Mark translations as outdated if the submitted value is true.
 */
function entity_translation_field_attach_submit($entity_type, $entity, $form, &$form_state) {
  if (entity_translation_enabled($entity_type) && !entity_translation_node($entity_type, $entity)) {
    $handler = entity_translation_get_handler($entity_type, $entity, TRUE);
    $langcode = $handler->getLanguage();
    $form_langcode = $handler->getFormLanguage();
    $translations = $handler->getTranslations();
    $is_translation = $form_langcode != $langcode && !$handler->isNewEntity();

    if (isset($form_state['values']['translation'])) {
      $values = $form_state['values']['translation'];
    }
    else {
      $values = array(
        'status' => $form_state['values']['status'],
        'retranslate' => 0,
      );
    }

    if (!isset($translations->data[$form_langcode])) {
      // If we have a new translation the language is the original entity
      // language.
      $tab_info = entity_translation_tab_info();
      $translation = $is_translation ? array('language' => $form_langcode, 'source' => $tab_info['source']) : array('language' => $langcode, 'source' => '');
    }
    else {
      $translation = $translations->data[$form_langcode];
    }

    if ($is_translation) {
      $translation['translate'] = intval($values['translate']);
    }
    else {
      $handler->setOriginalLanguage($langcode);
      $handler->setOutdated($values['retranslate']);
      // Inherit entity authoring information for the original values.
      $values['name'] = $form_state['values']['name'];
      $values['created'] = $form_state['values']['date'];
    }

    $translation['status'] = intval($values['status']);
    $translation['uid'] = user_load_by_name($values['name'])->uid;
    $translation['created'] = empty($values['created']) ? REQUEST_TIME : strtotime($values['created']);
    $handler->setTranslation($translation);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Enable a selector to choose whether a field is translatable.
 */
function entity_translation_form_field_ui_field_settings_form_alter(&$form, $form_state) {
  $instance = $form_state['build_info']['args'][0];
  $field = field_info_field($instance['field_name']);
  $form['field']['translatable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Users may translate this field.'),
    '#default_value' => $field['translatable'],
  );
}

/**
 * Translation handler factory.
 *
 * @param $entity_type
 *   The type of $entity; e.g. 'node' or 'user'.
 * @param $entity
 *   The entity to be translated.
 * @param $update
 *   Instances are statically cached: if this is TRUE the wrapped entity will
 *   be replaced by the passed one.
 *
 * @return
 *   A class implementing the EntityTranslationHandler interface.
 */
function entity_translation_get_handler($entity_type, $entity, $update = FALSE) {
  static $drupal_static_fast;
  if (!isset($drupal_static_fast['handlers'])) {
    $drupal_static_fast['handlers'] = &drupal_static(__FUNCTION__, array());
  }
  $handlers = &$drupal_static_fast['handlers'];

  list($entity_id) = entity_extract_ids($entity_type, $entity);

  if (!isset($handlers[$entity_type][$entity_id])) {
    $entity_info = entity_get_info($entity_type);
    $class = $entity_info['translation']['entity_translation']['class'];
    $handler = new $class($entity_type, $entity_info, $entity, $entity_id);

    // If the entity id is empty we cannot cache the translation handler
    // instance.
    if (empty($entity_id)) {
      return $handler;
    }
    else {
      $handlers[$entity_type][$entity_id] = $handler;
    }
  }
  elseif ($update) {
    $handlers[$entity_type][$entity_id]->setEntity($entity);
  }

  return $handlers[$entity_type][$entity_id];
}

/**
 * Return an array of edit form info as defined in hook_translation_info().
 *
 * @param $form
 *   The entity edit form.
 *
 * @return
 *   An edit form info array containing the entity to be translated in the
 *   'entity' key.
 */
function entity_translation_edit_form_info($form) {
  if (isset($form['#entity_type']) && isset($form['#' . $form['#entity_type']])) {
    $entity_info = entity_get_info();
    if (!empty($entity_info[$form['#entity_type']]['translation']['entity_translation']['edit form'])) {
      return array(
        'entity type' => $form['#entity_type'],
        'entity' => $form['#' . $form['#entity_type']],
      );
    }
  }
  return FALSE;
}

/**
 * Check if an entity translation is accessible.
 *
 * @param $translation
 *   An array representing an entity translation.
 *
 * @return
 *   TRUE if the current user is allowed to view the translation.
 */
function entity_translation_access($entity_type, $translation) {
  return $translation['status'] || user_access('translate any entity') || user_access("translate $entity_type entities");
}

/**
 * TODO
 */
function entity_translation_languages($entity_type = NULL, $entity = NULL) {
  if (isset($entity) && $entity_type == 'node' && module_exists('i18n_node')) {
    // @todo Inherit i18n language settings.
  }
  elseif (variable_get('entity_translation_languages_enabled', FALSE)) {
    $languages = language_list('enabled');
    return $languages[1];
  }
  return language_list();
}
