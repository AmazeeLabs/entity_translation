<?php

/**
 * @file
 * Allows entities to be translated into different languages.
 *
 * @todo
 * - menu
 * - core entities
 */

module_load_include('inc', 'entity_translation', 'entity_translation.node');

/**
 * TODO
 */
function entity_translation_language($entity_type, $entity) {
  $handler = entity_translation_get_handler($entity_type, $entity);
  $langcode = $handler->getFormLanguage();
  return !empty($langcode) ? $langcode : $handler->getLanguage();
}

/**
 * Helper function to determine if the given entity type is translatable.
 */
function entity_translation_enabled($entity_type, $skip_handler = FALSE) {
  $enabled_types = variable_get('entity_translation_entity_types', array());
  return !empty($enabled_types[$entity_type]) && ($skip_handler || field_has_translation_handler($entity_type, 'entity_translation'));
}

/**
 * Implements hook_language_type_info_alter().
 */
function entity_translation_language_types_info_alter(array &$language_types) {
  unset($language_types[LANGUAGE_TYPE_CONTENT]['fixed']);
}

/**
 * Implements hook_translation_info().
 */
function entity_translation_translation_info($types = NULL) {
  $info = array(
    'comment' => array(
      'translation' => array(
        'entity_translation' => array(
          'edit form' => FALSE,
        ),
      ),
    ),
    'node' => array(
      'translation' => array(
        'entity_translation' => array(
          'class' => 'EntityTranslationNodeHandler',
          'alias' => TRUE,
          'access callback' => 'entity_translation_node_tab_access',
          'access arguments' => array(1),
        ),
      ),
    ),
    'taxonomy_term' => array(
      'translation' => array(
        'entity_translation' => array(
          'base path' => 'taxonomy/term/%taxonomy_term',
          'alias' => TRUE,
        ),
      ),
    ),
    'user' => array(
    ),
  );

  return isset($types) ? array_intersect_key($info, $types) : $info;
}

/**
 * Implements hook_entity_info_alter().
 */
function entity_translation_entity_info_alter(&$entity_info) {
  // Collect entity-specific translation information.
  $types = array_flip(array_keys($entity_info));
  $translation_info = module_invoke_all('translation_info', $types);
  $entity_info = array_merge_recursive($entity_info, $translation_info);
  $edit_form_info = array();

  // Provide defaults for translation info.
  foreach ($entity_info as $entity_type => $info) {
    if (!isset($entity_info[$entity_type]['translation']['entity_translation'])) {
      $entity_info[$entity_type]['translation']['entity_translation'] = array();
    }

    // Every fieldable entity type must have a translation handler class, no
    // matter if it is enabled for translation or not. As a matter of fact we
    // might need it to correctly switch field translatability when a field is
    // shared accross different entities.
    $entity_info[$entity_type]['translation']['entity_translation'] += array('class' => 'EntityTranslationDefaultHandler');

    if (entity_translation_enabled($entity_type, TRUE)) {
      $entity_info[$entity_type]['language callback'] = 'entity_translation_language';

      // If no base path is provided we default to the common "node/%node"
      // pattern.
      if (!isset($entity_info[$entity_type]['translation']['entity_translation']['base path'])) {
        // Give a hint we are not done yet with entity translation information
        // building, since if caches have been cleared also menu cache is going
        // to be rebuilt and would retrieve an incomplete entity information.
        $GLOBALS['entity_translation_info_building'] = TRUE;
        $router = menu_get_router();
        unset($GLOBALS['entity_translation_info_building']);

        // If we cannot find a usable base path we skip to the next entity type.
        if (!isset($router["$entity_type/%"])) {
          continue;
        }

        $path = "$entity_type/%$entity_type";
        $entity_info[$entity_type]['translation']['entity_translation']['base path'] = $path;
      }

      $path = $entity_info[$entity_type]['translation']['entity_translation']['base path'];

      $entity_info[$entity_type]['translation']['entity_translation'] += array(
        'view path' => $path,
        'edit path' => "$path/edit",
        'path wildcard' => "%$entity_type",
        'access callback' => 'entity_translation_tab_access',
        'access arguments' => array($entity_type),
        'theme callback' => 'variable_get',
        'theme arguments' => array('admin_theme'),
        'edit form' => TRUE,
      );

      $entity_info[$entity_type]['entity keys'] += array(
        'translations' => 'translations',
      );
    }
  }
}

/**
 * Implements hook_menu().
 */
function entity_translation_menu() {
  $items = array();

  $items['admin/config/regional/entity_translation'] = array(
    'title' => 'Entity translation',
    'description' => 'Configure which entities can be translated and enable or disable language falback.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_translation_admin_form'),
    'access arguments' => array('administer entity translation'),
    'file' => 'entity_translation.admin.inc',
    'module' => 'entity_translation',
  );

  $items['admin/config/regional/entity_translation/translatable/%'] = array(
    'title' => 'Confirm change in translatability.',
    'description' => 'Confirm page for changing field translatability.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_translation_translatable_form', 5),
    'access arguments' => array('toggle field translatability'),
    'file' => 'entity_translation.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function entity_translation_menu_alter(&$items) {
  // If entity translation information is being rebuilt we must not proceed to
  // avoid recursion.
  if (!empty($GLOBALS['entity_translation_info_building'])) {
    return;
  }

  $backup = array();
  $languages = entity_translation_languages();

  // Create tabs for all possible entity types.
  foreach (entity_get_info() as $entity_type => $info) {
    // Menu is rebuilt while determining entity translation base paths and
    // callbacks so we might not have them available yet.
    if (entity_translation_enabled($entity_type)) {
      // Extract informations from the bundle description.
      $path = $info['translation']['entity_translation']['base path'];
      $keys = array('theme callback', 'theme arguments', 'access callback', 'access arguments', 'load arguments');
      $item = array_intersect_key($info['translation']['entity_translation'], drupal_map_assoc($keys));

      $item += array(
        'file' => 'entity_translation.admin.inc',
        'module' => 'entity_translation',
      );

      $entity_position = count(explode('/', $path)) - 1;
      $source_position = $entity_position + 4;
      $language_position = $entity_position + 3;

      // Backup existing values for the translate overview page.
      if (isset($items["$path/translate"])) {
        $backup[$entity_type] = $items["$path/translate"];
      }

      $items["$path/translate"] = array(
        'title' => 'Translate',
        'page callback' => 'entity_translation_overview',
        'page arguments' => array($entity_type, $entity_position),
        'type' => MENU_LOCAL_TASK,
        'weight' => 2,
      ) + $item;

      $et_info = $info['translation']['entity_translation'];
      $edit_path = $et_info['edit path'];

      if (isset($items[$edit_path])) {
        // Replace the main edit callback with our proxy implementation to set
        // form language to the current language.
        $edit_form_item = $items[$edit_path];
        $entity_position = count(explode('/', $et_info['base path'])) - 1;
        $edit_position = count(explode('/', $edit_path)) - 1;
        $items[$edit_path]['page callback'] = 'entity_translation_edit_page';
        $items[$edit_path]['page arguments'] = array_merge(array($entity_type, $entity_position, FALSE, $edit_form_item), $edit_form_item['page arguments']);

        // Edit translation callback.
        $translation_position = $edit_position + 1;
        $items["$edit_path/%entity_translation_language"] = array(
          'type' => MENU_DEFAULT_LOCAL_TASK,
          'title callback' => 'entity_translation_edit_title',
          'title arguments' => array($translation_position),
          'page callback' => 'entity_translation_edit_page',
          'page arguments' => array_merge(array($entity_type, $entity_position, $translation_position, $edit_form_item), $edit_form_item['page arguments']),
          'access callback' => 'entity_translation_edit_access',
          'access arguments' => array_merge(array($entity_type, $entity_position, $translation_position, $edit_form_item), $edit_form_item['access arguments']),
        )
        // We need to inherit the remaining menu item keys, mostly 'module' and
        // 'file' to keep ajax callbacks working (see drupal_retrieve_form() and
        // form_get_cache()).
        + $edit_form_item;

        // Add translation callback.
        $add_path = "$edit_path/add/%entity_translation_language";
        $source_position = $edit_position + 2;
        $items[$add_path] = array(
          'title callback' => 'Add translation',
          'page callback' => 'entity_translation_add_page',
          'page arguments' => array_merge(array($entity_type, $entity_position, $source_position, $source_position + 1, $edit_form_item), $edit_form_item['page arguments']),
          'type' => MENU_LOCAL_TASK,
          'access callback' => 'entity_translation_add_access',
          'access arguments' => array_merge(array($entity_type, $entity_position, $source_position, $source_position + 1, $edit_form_item), $edit_form_item['access arguments']),
        ) + $edit_form_item;

        // Delete translation callback.
        $items["$edit_path/delete/%entity_translation_language"] = array(
          'title' => 'Delete',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('entity_translation_delete_confirm', $entity_type, $entity_position, $language_position),
        ) + $item;
      }
    }
  }

  // Node-specific menu alterations.
  entity_translation_node_menu_alter($items, $backup);
}

/**
 * Title callback. 
 */
function entity_translation_edit_title($langcode) {
  $languages = entity_translation_languages();
  return isset($languages[$langcode]) ? t($languages[$langcode]->name) : '';
}

/**
 * Page callback.
 */
function entity_translation_edit_page() {
  $args = func_get_args();
  $entity_type = array_shift($args);
  $entity = array_shift($args);
  $langcode = array_shift($args);
  $edit_form_item = array_shift($args);

  // Set the current form language.
  $langcode = entity_translation_form_language($entity_type, $entity, $langcode);
  $handler = entity_translation_get_handler($entity_type, $entity);
  $handler->setFormLanguage($langcode);

  // Display the entity edit form.
  return _entity_translation_callback($edit_form_item['page callback'], $args, $edit_form_item);
}

/**
 * Access callback.
 */
function entity_translation_edit_access() {
  $args = func_get_args();
  $entity_type = array_shift($args);
  $entity = array_shift($args);
  $langcode = array_shift($args);

  $handler = entity_translation_get_handler($entity_type, $entity);
  $translations = $handler->getTranslations();

  // If the translation exists, we can show the corresponding local task.
  if (isset($translations->data[$langcode])) {
    // Check that the requested language is actually accessible.
    $enabled_languages = entity_translation_languages($entity_type, $entity);
    if (isset($enabled_languages[$langcode])) {
      $edit_form_item = array_shift($args);
      return _entity_translation_callback($edit_form_item['access callback'], $args, $edit_form_item);
    }
  }

  return FALSE;
}

/**
 * Access callback.
 */
function entity_translation_add_access() {
  $args = func_get_args();
  $entity_type = array_shift($args);
  $entity = array_shift($args);
  $source = array_shift($args);
  $langcode = array_shift($args);

  $handler = entity_translation_get_handler($entity_type, $entity);
  $translations = $handler->getTranslations();

  // If the translation does not exist we can show the tab.
  if (!isset($translations->data[$langcode]) && $langcode != $source) {
    // Check that the requested language is actually accessible.
    $enabled_languages = entity_translation_languages($entity_type, $entity);
    if (isset($enabled_languages[$langcode])) {
      $edit_form_item = array_shift($args);
      return _entity_translation_callback($edit_form_item['access callback'], $args, $edit_form_item);
    }
  }

  return FALSE;
}

/**
 * Page callback.
 */
function entity_translation_add_page() {
  $args = func_get_args();
  $entity_type = array_shift($args);
  $entity = array_shift($args);
  $source = array_shift($args);
  $langcode = array_shift($args);
  $edit_form_item = array_shift($args);

  $handler = entity_translation_get_handler($entity_type, $entity);
  $handler->setFormLanguage($langcode);
  $handler->setSourceLanguage($source);

  // Display the entity edit form.
  return _entity_translation_callback($edit_form_item['page callback'], $args, $edit_form_item);
}

/**
 * TODO
 */
function entity_translation_form_language($entity_type, $entity, $langcode = NULL) {
  if (empty($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }
  $handler = entity_translation_get_handler($entity_type, $entity);
  $translations = $handler->getTranslations();
  return isset($translations->data[$langcode]) ? $langcode : $handler->getLanguage();
}

/**
 * TODO
 */
function _entity_translation_callback($callback, $args, $info = array()) {
  if (isset($info['file'])) {
    $path = isset($info['file path']) ? $info['file path'] : drupal_get_path('module', $info['module']);
    include_once DRUPAL_ROOT . '/' . $path . '/' . $info['file'];
  }
  return call_user_func_array($callback, $args);
}

/**
 * TODO
 */
function entity_translation_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // When displaying the main edit form, we need to mark as active the tab
  // corresponding to the current language.
  $handler = entity_translation_get_handler();
  if (!empty($handler) && ($form_langcode = $handler->getFormLanguage()) && drupal_multilingual()) {
    $translations = $handler->getTranslations();

    if (count($translations->data) > 1) {
      $languages = language_list();

      if ($handler->getSourceLanguage()) {
        foreach ($data['tabs'][1]['output'] as &$add_tab) {
          if ($add_tab['#link']['path'] == $root_path) {
            $add_tab['#link']['title'] = $languages[$form_langcode]->name;
            $add_tab['#link']['weight'] = -$languages[$form_langcode]->weight;
            $add_tab['#active'] = TRUE;
            break;
          }
        }
      }

      foreach ($translations->data as $langcode => $translation) {
        $links = _entity_translation_language_switch_links($handler->getEditPath($langcode));
        $link = $links->links[$langcode];
        $tab = array();
        $tab['#theme'] = 'menu_local_task';
        $tab['#active'] = $langcode == $form_langcode;
        $tab['#link'] = array(
          'href' => $link['href'],
          'title' => $languages[$langcode]->name,
          'weight' => -$languages[$langcode]->weight,
          'localized_options' => $link,
        ) + $router_item;
        $data['tabs'][1]['output'][] = $tab;
      }

      $data['tabs'][1]['count'] = count($data['tabs'][1]['output']);

      // Reorder tabs to make the add tab respect language weights.
      usort($data['tabs'][1]['output'], '_entity_translation_tab_sort');
    }
  }
}

function _entity_translation_language_switch_links($path) {
  $links = language_negotiation_get_switch_links(LANGUAGE_TYPE_CONTENT, $path);
  if (empty($links)) {
    // If content language is set up to fall back to the interface language,
    // then there will be no switch links for LANGUAGE_TYPE_CONTENT, ergo we
    // also need to use interface switch links.
    $links = language_negotiation_get_switch_links(LANGUAGE_TYPE_INTERFACE, $path);
  }
  return $links;
}

/**
 * TODO
 */
function _entity_translation_tab_sort($a, $b) {
  return $a['#link']['weight'] > $b['#link']['weight'];
}

/**
 * Implements hook_admin_paths().
 */
function entity_translation_admin_paths() {
  $paths = array();
  foreach (entity_get_info() as $entity_type => $info) {
    if (entity_translation_enabled($entity_type, TRUE) && isset($info['translation']['entity_translation']['base path'])) {
      $base_path = preg_replace('|%[^/]*|', '*', $info['translation']['entity_translation']['base path']);
      $paths["$base_path/translate"] = TRUE;
      $paths["$base_path/translate/*"] = TRUE;
      $paths["$base_path/edit/*"] = TRUE;
    }
  }
  return $paths;
}

/**
 * Access callback.
 */
function entity_translation_tab_access($entity_type) {
  return drupal_multilingual() && (user_access('translate any entity') || user_access("translate $entity_type entities"));
}

/**
 * Menu loader callback.
 */
function entity_translation_language_load($langcode, $entity_type = NULL, $entity = NULL) {
  $enabled_languages = entity_translation_languages($entity_type, $entity);
  return isset($enabled_languages[$langcode]) ? $langcode : FALSE;
}

/**
 * Menu loader callback.
 */
function entity_translation_menu_entity_load($entity_id, $entity_type) {
  $entities = entity_load($entity_type, array($entity_id));
  return $entities[$entity_id];
}

/**
 * Implements hook_permission().
 */
function entity_translation_permission() {
  $permission = array(
    'translate any entity' => array(
      'title' => t('Translate any entity'),
      'description' => t('Translate field content for any fieldable entity.'),
    ),
    'administer entity translation' => array(
      'title' => t('Administer entity translation'),
      'description' => t('Select which entities can be translated.'),
    ),
    'toggle field translatability' => array(
      'title' => t('Toggle field translatability'),
      'description' => t('Toggle translatability of fields performing a bulk update.'),
    ),
  );
  foreach (entity_get_info() as $entity_type => $info) {
    if ($info['fieldable']) {
      $label = t($info['label']);
      $permission["translate $entity_type entities"] = array(
        'title' => t('Translate entities of type @type', array('@type' => $label)),
        'description' => t('Translate field content for entities of type @type', array('@type' => $label)),
      );
    }
  }
  return $permission;
}

/**
 * Implements hook_theme().
 */
function entity_translation_theme() {
  return array(
    'entity_translation_unavailable' => array(
      'variables' => array('element' => NULL),
    ),
  );
}

/**
 * Implements hook_entity_load().
 */
function entity_translation_entity_load($entities, $entity_type) {
  if (entity_translation_enabled($entity_type)) {
    EntityTranslationDefaultHandler::loadMultiple($entity_type, $entities);
  }
}

/**
 * Implements hook_field_language_alter().
 *
 * Performs language fallback for unaccessible translations.
 */
function entity_translation_field_language_alter(&$display_language, $context) {
  if (variable_get('locale_field_language_fallback', TRUE) && entity_translation_enabled($context['entity_type'])) {
    $entity = $context['entity'];
    $entity_type = $context['entity_type'];
    $handler = entity_translation_get_handler($entity_type, $entity);
    $translations = $handler->getTranslations();

    // Apply fallback only on unpublished translations as missing translations
    // are already handled in locale_field_language_alter().
    if (isset($translations->data[$context['language']]) && !entity_translation_access($entity_type, $translations->data[$context['language']])) {
      list(, , $bundle) = entity_extract_ids($entity_type, $entity);
      $instances = field_info_instances($entity_type, $bundle);
      $entity = clone($entity);

      foreach ($translations->data as $langcode => $translation) {
        if ($langcode == $context['language'] || !entity_translation_access($entity_type, $translations->data[$langcode])) {
          // Unset unaccessible field translations: if the field is
          // untranslatable unsetting a language different from LANGUAGE_NONE
          // has no effect.
          foreach ($instances as $instance) {
            unset($entity->{$instance['field_name']}[$langcode]);
          }
        }
      }

      // Find the new fallback values.
      locale_field_language_fallback($display_language, $entity, $context['language']);
    }
    elseif (!field_has_translation_handler($entity_type, 'locale')) {
      // If not handled by the Locale translation handler trigger fallback too.
      locale_field_language_fallback($display_language, $entity, $context['language']);
    }
  }
}

/**
 * Implements hook_field_attach_view_alter().
 *
 * Hide the entity if no translation is available for the current language and
 * language fallback is disabled.
 */
function entity_translation_field_attach_view_alter(&$output, $context) {
  if (!variable_get('locale_field_language_fallback', TRUE) && entity_translation_enabled($context['entity_type'])) {
    $handler = entity_translation_get_handler($context['entity_type'], $context['entity']);
    $translations = $handler->getTranslations();
    $langcode = $GLOBALS['language_content']->language;

    // If fallback is disabled we need to notify the user that the translation
    // is unavailable (missing or unpublished).
    if (!isset($translations->data[$langcode]) || !entity_translation_access($context['entity_type'], $translations->data[$langcode])) {
      // Provide context for rendering.
      $output['#entity'] = $context['entity'];
      $output['#entity_type'] = $context['entity_type'];
      $output['#view_mode'] = $context['view_mode'];
      // We perform theming here because the theming function might need to set
      // system messages. It would be too late in the #post_render callback.
      $output['#entity_translation_unavailable'] = theme('entity_translation_unavailable', array('element' => $output));
      // As we used a string key, other modules implementing
      // hook_field_attach_view_alter() may unset/override this.
      $output['#post_render']['entity_translation'] = 'entity_translation_unavailable';
    }
  }
}

/**
 * Override the entity output with the unavailable translation one.
 */
function entity_translation_unavailable($children, $element) {
  return $element['#entity_translation_unavailable'];
}

/**
 * Theme an unvailable translation.
 */
function theme_entity_translation_unavailable($variables) {
  $element = $variables['element'];
  $handler = entity_translation_get_handler($element['#entity_type'], $element['#entity']);
  $args = array('%language' => t($GLOBALS['language_content']->name), '%label' => $handler->getLabel());
  $message = t('%language translation unavailable for %label.', $args);
  $classes = $element['#entity_type'] . ' ' . $element['#entity_type'] . '-' . $element['#view_mode'];
  return "<div class=\"$classes\"><div class=\"messages warning\">$message</div></div>";
}

/**
 * Implements hook_field_attach_insert().
 */
function entity_translation_field_attach_insert($entity_type, $entity) {
  if (entity_translation_enabled($entity_type)) {
    $handler = entity_translation_get_handler($entity_type, $entity);
    $handler->initTranslations();
    $handler->saveTranslations();
  }
}

/**
 * Implements hook_field_attach_update().
 */
function entity_translation_field_attach_update($entity_type, $entity) {
  if (entity_translation_enabled($entity_type)) {
    $handler = entity_translation_get_handler($entity_type, $entity, TRUE);
    $handler->updateTranslations();
    $handler->saveTranslations();
  }
}

/**
 * Implements hook_field_attach_delete().
 */
function entity_translation_field_attach_delete($entity_type, $entity) {
  if (entity_translation_enabled($entity_type)) {
    $handler = entity_translation_get_handler($entity_type, $entity);
    $handler->removeTranslations();
    $handler->saveTranslations();
  }
}

/**
 * Implementation of hook_field_attach_form().
 */
function entity_translation_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  // Skip recursing into the source form.
  if (empty($form['#source_form']) && entity_translation_enabled($entity_type) && ($handler = entity_translation_get_handler_form($form, $form_state))) {
    $form_langcode = $handler->getFormLanguage();
    $translations = $handler->getTranslations();
    $update_langcode = $form_langcode != $langcode;
    $source = $handler->getSourceLanguage();

    // If we are creating a new translation we need to retrieve form elements
    // populated with the source language values, but only if form is not being
    // rebuilt. In this case source values have already been populated, so we
    // need to preserve possible changes. There might be situations, e.g. ajax
    // calls, where the form language has not been properly initialized before
    // calling field_attach_form(). In this case we need to rebuild the form
    // with the correct form language and replace the field elements with the
    // correct ones.
    if ($update_langcode || ($source && !isset($translations->data[$form_langcode]) && isset($translations->data[$source]))) {
      list(, , $bundle) = entity_extract_ids($entity_type, $entity);

      foreach (field_info_instances($entity_type, $bundle) as $instance) {
        $field_name = $instance['field_name'];
        $field = field_info_field($field_name);

        // If we are creating a new translation we have to change the form item
        // language information from source to target language, this way the
        // user can find the form items already populated with the source values
        // while the field form element holds the correct language information.
        if ($field['translatable']) {
          $form[$field_name]['#field_name'] = $field_name;
          $form[$field_name]['#source'] = $update_langcode ? $form_langcode : $source;
          $form[$field_name]['#previous'] = NULL;

          // If we are updating the form language we need to make sure that the
          // wrong language is unset and the right one is stored in the field
          // element (see entity_translation_prepare_element()).
          if ($update_langcode) {
            $form[$field_name]['#previous'] = $form[$field_name]['#language'];
            $form[$field_name]['#language'] = $form_langcode;
          }

          // Swap default values during form processing to avoid recursion. We
          // try to act before any other callback so that the correct values are
          // already in place for them.
          if (!isset($form[$field_name]['#process'])) {
            $form[$field_name]['#process'] = array();
          }
          array_unshift($form[$field_name]['#process'], 'entity_translation_prepare_element');
        }
      }
    }
  }
}

/**
 * Form element process callback.
 */
function entity_translation_prepare_element($element, &$form_state) {
  $source_form = &drupal_static(__FUNCTION__, array());
  $form = $form_state['complete form'];
  $build_id = $form['#build_id'];
  $source = $element['#source'];

  if (!isset($source_form[$build_id][$source])) {
    $source_form[$build_id][$source] = array('#source_form' => TRUE);
    $source_form_state = $form_state;
    $info = entity_translation_edit_form_info($form);
    field_attach_form($info['entity type'], $info['entity'], $source_form[$build_id][$source], $source_form_state, $source);
  }

  $langcode = $element['#language'];
  $field_name = $element['#field_name'];

  // If we are creating a new translation we have to change the form item
  // language information from source to target language, this way the user can
  // find the form items already populated with the source values while the
  // field form element holds the correct language information.
  if (isset($source_form[$build_id][$source][$field_name][$source])) {
    $element[$langcode] = $source_form[$build_id][$source][$field_name][$source];
    array_walk_recursive($element[$langcode], '_entity_translation_form_language_callback', $langcode);
    unset($element[$element['#previous']]);
  }

  return $element;
}

/**
 * Helper callback: replace the source language with the given one.
 */
function _entity_translation_form_language_callback(&$item, $key, $langcode) {
  if ($key === '#language') {
    $item = $langcode;
  }
}

/**
 * Implements hook_form_alter().
 */
function entity_translation_form_alter(&$form, &$form_state) {
  if (($handler = entity_translation_get_handler_form($form, $form_state)) && !$handler->isNewEntity()) {
    $translations = $handler->getTranslations();
    $form_langcode = $handler->getFormLanguage();
    $langcode = $handler->getLanguage();
    $is_translation = $langcode != $form_langcode;
    $new_translation = !isset($translations->data[$form_langcode]);

    // Display source language selector only if we are creating a new translation
    // and there are at least two translations available.
    if ($new_translation && count($translations->data) > 1) {
      $form['source_language'] = array(
        '#type' => 'fieldset',
        '#title' => t('Source language'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#tree' => TRUE,
        '#weight' => -100,
        'language' => array(
          '#type' => 'select',
          '#default_value' => $handler->getSourceLanguage(),
          '#options' => array(),
        ),
        'submit' => array(
          '#type' => 'submit',
          '#value' => t('Change'),
          '#submit' => array('entity_translation_entity_form_source_language_submit'),
        ),
      );
      foreach (language_list() as $language) {
        if (isset($translations->data[$language->language])) {
          $form['source_language']['language']['#options'][$language->language] = t($language->name);
        }
      }
    }

    if ($is_translation) {
      if (isset($form['language'])) {
        // If we are editing a translation set the correct value in the
        // language widget and not current one.
        // @todo Consider supporting the ability to change translation
        // language.
        $languages = language_list();
        $form['language']['#options'][$langcode] = $languages[$langcode]->name;
        $form['language']['#default_value'] = $langcode;
        $form['language']['#disabled'] = TRUE;
      }

      // Replace the delete button with the delete translation one.
      if (!$new_translation) {
        $form['actions']['delete_translation'] = array(
          '#type' => 'submit',
          '#value' => t('Delete translation'),
          '#weight' => $form['actions']['delete'],
          '#submit' => array('entity_translation_entity_form_delete_translation_submit'),
        );
      }
      unset($form['actions']['delete']);

      // Set page title.
      $args = array('@label' => $handler->getLabel(), '@language' => t($languages[$form_langcode]->name));
      drupal_set_title(t('@label [@language translation]', $args));
    }
    else {
      $form['actions']['delete']['#submit'][] = 'entity_translation_entity_form_delete_submit';
    }

    // We need to display the translation tab only when there is at least one
    // translation available or a new one is about to be created.
    if ($new_translation || count($translations->data) > 1) {
      $form['translation'] = array(
        '#type' => 'fieldset',
        '#title' => t('Translation'),
        '#collapsible' => TRUE,
        '#tree' => TRUE,
      );

      $status = $new_translation || $translations->data[$form_langcode]['status'];
      $enabled = !$status;
      // If there is only one published translation we cannot unpublish it,
      // since there would be no content left to display. The whole entity
      // should be unpublished instead, where possible.
      if (!empty($status)) {
        $published = 0;
        foreach ($translations->data as $langcode => $translation) {
          $published += $translation['status'];
        }
        $enabled = $published > 1;
      }
      $description = $enabled ?
        t('An unpublished translation will not be visible for non-administrators.') :
        t('Only this translation is published. You must publish at least one more translation to unpublish this one.');

      $form['translation']['status'] = array(
        '#type' => 'checkbox',
        '#title' => t('This translation is published'),
        '#default_value' => $status,
        '#description' => $description,
        '#disabled' => !$enabled,
      );

      if (!$is_translation) {
        $form['translation']['retranslate'] = array(
          '#type' => 'checkbox',
          '#title' => t('Flag translations as outdated'),
          '#default_value' => 0,
          '#description' => t('If you made a significant change, which means translations should be updated, you can flag all translations of this post as outdated. This will not change any other property of those posts, like whether they are published or not.'),
        );
      }
      else {
        $translate = !$new_translation && $translations->data[$form_langcode]['translate'];
        $form['translation']['translate'] = array(
          '#type' => 'checkbox',
          '#title' => t('This translation needs to be updated'),
          '#default_value' => $translate,
          '#description' => t('When this option is checked, this translation needs to be updated because the source post has changed. Uncheck when the translation is up to date again.'),
          '#disabled' => !$translate,
        );

        $name = $new_translation ? '' : user_load($translations->data[$form_langcode]['uid'])->name;
        $form['translation']['name'] = array(
          '#type' => 'textfield',
          '#title' => t('Authored by'),
          '#maxlength' => 60,
          '#autocomplete_path' => 'user/autocomplete',
          '#default_value' => $name,
          '#description' => t('Leave blank for %anonymous.', array('%anonymous' => variable_get('anonymous', t('Anonymous')))),
        );

        $date = $new_translation ? REQUEST_TIME : $translations->data[$form_langcode]['created'];
        $form['translation']['created'] = array(
          '#type' => 'textfield',
          '#title' => t('Authored on'),
          '#maxlength' => 25,
          '#description' => t('Format: %time. The date format is YYYY-MM-DD and %timezone is the time zone offset from UTC. Leave blank to use the time of form submission.', array('%time' => format_date($date, 'custom', 'Y-m-d H:i:s O'), '%timezone' => format_date($date, 'custom', 'O'))),
          '#default_value' => $new_translation ? '' : format_date($date, 'custom', 'Y-m-d H:i:s O'),
        );
      }
    }

    array_unshift($form['#validate'], 'entity_translation_entity_form_validate');

    // Node specific alterations.
    if ($form['#entity_type'] == 'node') {
      entity_translation_node_alter_form($form, $form_state, $handler);
    }
  }
}

/**
 * Submit handler for the source language selector.
 */
function entity_translation_entity_form_source_language_submit($form, &$form_state) {
  $handler = entity_translation_get_handler_form($form, $form_state);
  $langcode = $form_state['values']['source_language']['language'];
  $path = "{$handler->getEditPath()}/add/$langcode/{$handler->getFormLanguage()}";
  $form_state['redirect'] = array('path' => $path);
  $languages = language_list();
  drupal_set_message(t('Source translation set to: %language', array('%language' => t($languages[$langcode]->name))));
}

/**
 * Submit handler for the entity deletion.
 */
function entity_translation_entity_form_delete_submit($form, &$form_state) {
  $info = entity_get_info($form['#entity_type']);
  drupal_set_message(t('This will delete all the @entity_type translations.', array('@entity_type' => drupal_strtolower($info['label']))), 'warning');
}

/**
 * Submit handler for the translation deletion.
 */
function entity_translation_entity_form_delete_translation_submit($form, &$form_state) {
  $handler = entity_translation_get_handler_form($form, $form_state);
  $form_state['redirect'] = "{$handler->getEditPath()}/delete/{$handler->getFormLanguage()}";
}

/**
 * Validation handler for the entity edit form.
 */
function entity_translation_entity_form_validate($form, &$form_state) {
  if (isset($form_state['values']['language']) && empty($form['language']['#attributes']['disabled'])) {
    $info = entity_translation_edit_form_info($form);
    $handler = entity_translation_get_handler_form($form, $form_state);
    // Update the form language as it might have changed.
    $handler->setFormLanguage($form_state['values']['language']);
  }
}

/**
 * Implementation of hook_field_attach_submit().
 *
 * Mark translations as outdated if the submitted value is true.
 */
function entity_translation_field_attach_submit($entity_type, $entity, $form, &$form_state) {
  if (entity_translation_enabled($entity_type) && !entity_translation_node($entity_type, $entity)) {
    $handler = entity_translation_get_handler_form($form, $form_state);
    $handler->setEntity($entity);
    $langcode = $handler->getLanguage();
    $form_langcode = $handler->getFormLanguage();
    $translations = $handler->getTranslations();
    $is_translation = $form_langcode != $langcode && !$handler->isNewEntity();

    if (isset($form_state['values']['translation'])) {
      $values = $form_state['values']['translation'];
    }
    else {
      $values = array(
        'status' => $form_state['values']['status'],
        'retranslate' => 0,
      );
    }

    if (!isset($translations->data[$form_langcode])) {
      // If we have a new translation the language is the original entity
      // language.
      $translation = $is_translation ? array('language' => $form_langcode, 'source' => $handler->getSourceLanguage()) : array('language' => $langcode, 'source' => '');
    }
    else {
      $translation = $translations->data[$form_langcode];
    }

    if ($is_translation) {
      $translation['translate'] = intval($values['translate']);
    }
    else {
      $handler->setOriginalLanguage($langcode);
      $handler->setOutdated($values['retranslate']);
      // Inherit entity authoring information for the original values.
      $values['name'] = $form_state['values']['name'];
      $values['created'] = $form_state['values']['date'];
    }

    $translation['status'] = intval($values['status']);
    $translation['uid'] = user_load_by_name($values['name'])->uid;
    $translation['created'] = empty($values['created']) ? REQUEST_TIME : strtotime($values['created']);
    $handler->setTranslation($translation);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Enable a selector to choose whether a field is translatable.
 */
function entity_translation_form_field_ui_field_edit_form_alter(&$form, $form_state) {
  $field_name = $form['#field']['field_name'];
  $field = field_info_field($field_name);
  $translatable = $field['translatable'];
  $label = t('Field translation');
  $title = t('Users may translate this field.');

  if (field_has_data($field)) {
    $path = "admin/config/regional/entity_translation/translatable/$field_name";
    $status = $translatable ? $title : t('This field is shared among the entity translations.');
    $link_title = !$translatable ? t('Enable translation') : t('Disable translation');

    $form['field']['translatable'] = array(
      '#prefix' => '<div class="translatable"><label>' . $label . '</label>',
      '#suffix' => '</div>',
      'message' => array(
        '#markup' => $status . ' ',
      ),
      'link' => array(
        '#type' => 'link',
        '#title' => $link_title,
        '#href' => $path,
        '#options' => array('query' => drupal_get_destination()),
        '#access' => user_access('toggle field translatability'),
      ),
    );
  }
  else {
    $form['field']['translatable'] = array(
      '#prefix' => '<label>' . $label . '</label>',
      '#type' => 'checkbox',
      '#title' => $title,
      '#default_value' => $translatable,
    );
  }
}

/**
 * Translation handler factory.
 *
 * @param $entity_type
 *   Optional. The type of $entity; e.g. 'node' or 'user'.
 * @param $entity
 *   Optional. The entity to be translated.
 * @param $update
 *   Optional. Instances are statically cached: if this is TRUE the wrapped
 *   entity will be replaced by the passed one.
 *
 * @return EntityTranslationHandlerInterface
 *   A class implementing EntityTranslationHandlerInterface.
 */
function entity_translation_get_handler($entity_type = NULL, $entity = NULL, $update = FALSE) {
  static $drupal_static_fast;
  if (!isset($drupal_static_fast['handlers'])) {
    $drupal_static_fast['handlers'] = &drupal_static(__FUNCTION__, array());
  }
  $handlers = &$drupal_static_fast['handlers'];

  // Workaround the lack of a context object.
  if (empty($entity)) {
    if (isset($handlers[$entity_type]['#current'])) {
      return $handlers[$entity_type]['#current'];
    }
    elseif (empty($entity_type) && isset($handlers['#current']['#current'])) {
      return $handlers['#current']['#current'];
    }
    else {
      return NULL;
    }
  }

  list($entity_id) = entity_extract_ids($entity_type, $entity);

  if (!isset($handlers[$entity_type][$entity_id])) {
    $entity_info = entity_get_info($entity_type);
    $class = $entity_info['translation']['entity_translation']['class'];
    $handler = new $class($entity_type, $entity_info, $entity, $entity_id);

    // If the entity id is empty we cannot cache the translation handler
    // instance.
    if (empty($entity_id)) {
      return $handler;
    }
    else {
      $handlers[$entity_type][$entity_id] = $handler;
    }
  }
  elseif ($update) {
    $handlers[$entity_type][$entity_id]->setEntity($entity);
  }

  $handlers[$entity_type]['#current'] = $handlers[$entity_type][$entity_id];
  $handlers['#current']['#current'] = $handlers[$entity_type][$entity_id];
  return $handlers[$entity_type][$entity_id];
}

/**
 * Returns the translation handler wrapping the entity being edited.
 *
 * @param $form
 *   The entity form.
 * @param $form_state
 *   A keyed array containing the current state of the form.
 *
 * @return EntityTranslationHandlerInterface
 *   A class implementing EntityTranslationHandlerInterface.
 */
function entity_translation_get_handler_form($form, &$form_state) {
  $handler = FALSE;

  if (empty($form_state['storage']['entity_translation']['handler'])) {
    $info = entity_translation_edit_form_info($form);
    if (entity_translation_enabled($info['entity type']) && !entity_translation_node($info['entity type'], $info['entity'])) {
      $handler = entity_translation_get_handler($info['entity type'], $info['entity']);
      $form_state['storage']['entity_translation']['handler'] = $handler;
    }
  }
  else {
    $handler = $form_state['storage']['entity_translation']['handler'];
  }

  return $handler;
}

/**
 * Return an array of edit form info as defined in hook_translation_info().
 *
 * @param $form
 *   The entity edit form.
 *
 * @return
 *   An edit form info array containing the entity to be translated in the
 *   'entity' key.
 */
function entity_translation_edit_form_info($form) {
  if (isset($form['#entity_type']) && isset($form['#' . $form['#entity_type']])) {
    $entity_info = entity_get_info();
    if (!empty($entity_info[$form['#entity_type']]['translation']['entity_translation']['edit form'])) {
      return array(
        'entity type' => $form['#entity_type'],
        'entity' => $form['#' . $form['#entity_type']],
      );
    }
  }
  return FALSE;
}

/**
 * Check if an entity translation is accessible.
 *
 * @param $translation
 *   An array representing an entity translation.
 *
 * @return
 *   TRUE if the current user is allowed to view the translation.
 */
function entity_translation_access($entity_type, $translation) {
  return $translation['status'] || user_access('translate any entity') || user_access("translate $entity_type entities");
}

/**
 * TODO
 */
function entity_translation_languages($entity_type = NULL, $entity = NULL) {
  if (isset($entity) && $entity_type == 'node' && module_exists('i18n_node')) {
    // @todo Inherit i18n language settings.
  }
  elseif (variable_get('entity_translation_languages_enabled', FALSE)) {
    $languages = language_list('enabled');
    return $languages[1];
  }
  return language_list();
}
